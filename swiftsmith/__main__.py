import argparse
import base64
import random
import swiftsmith
import sys

from swiftsmith.metamorphic import unnecessary_addition, unnecessary_multiplication

version = "v0.0.2"

########################################
#   Argument Parsing                   #
########################################

def mr(name):
    if name is None:
        return None
    """Converts the name of a metamorphic relation to th MR itself."""
    if name == "unnecessary-addition":
        return unnecessary_addition
    elif name == "unnecessary-multiplication":
        return unnecessary_multiplication
    else:
        raise NotImplementedError(f"No MR named '{name}'")

parser = argparse.ArgumentParser(prog="SwiftSmith")
parser.add_argument("seed", type=str, default="AA==")
parser.add_argument("--output", "-o", type=str)
parser.add_argument("-mr", type=mr)
parser.add_argument('--version', action='version', version='%(prog)s %(version)s')
parser.add_argument("--tests", type=str, default=None)

args = parser.parse_args()

########################################
#   Program Generation                 #
########################################

def decode_seed(b64str: str):
    binarystr = base64.b64decode(b64str)
    return int.from_bytes(binarystr, 'big', signed=False)

seed = decode_seed(args.seed)
random.seed(seed)

parsetree = swiftsmith.swift.randomtree()

# We play a game of musical chairs to ensure that the generated main function uses a
# function defined in the generated code instead of one imported from the standard
# library. Public symbols are visible from anywhere in the scope tree, so when the
# program is generated then the file scope and standard library scope must be in the
# same tree. When main is generated, they must be in different trees.

rootscope = swiftsmith.Scope()
rootscope.import_standard_library()
parsetree.annotate(scope=rootscope)

# break the link between rootscope and the standard library scopes
rootscope.children = [rootscope.children[-1]]

########################################
#   File I/O                           #
########################################

def openmodule(suffix):
    if args.output is None:
        return open("/dev/stdout", 'w')
    else:
        return open(args.output + f"{suffix}.swift", 'w')

def writemodule(suffix, code):
    with openmodule(suffix) as f:
        f.write(f"\n// Generated by Swiftsmith {version}")
        f.write(code)

def writetests(file):
    from swiftsmith.expression import FunctionCall
    from swiftsmith.semantics import SemanticParseTree

    f.write(f"\n// Generated by Swiftsmith {version}\n\n")
    modulename = args.output.split("/")[-1]
    f.write(f"import {modulename}A\n")
    f.write(f"import {modulename}B\n\n")

    for _ in range(50):
        fname, ftype = rootscope.choose_function(at_least=swiftsmith.AccessLevel.public)
        call = SemanticParseTree(FunctionCall(fname, ftype), [])
        call.annotate()
        # TODO: handle prefix, infix, and postfix functions
        f.write(f"assert(ModuleA.{call.string()} == ModuleB.{call.string()})\n")

if args.mr:
    writemodule("A", parsetree.string())
    args.mr(parsetree)
    writemodule("B", parsetree.string())

    if args.tests:
        with open(args.tests, 'w') as f:
            writetests(f)
else:
    writemodule("", parsetree.string())
